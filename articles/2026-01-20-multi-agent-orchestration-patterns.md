---
title: "ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³å®Œå…¨ã‚¬ã‚¤ãƒ‰"
emoji: "ğŸ­"
type: "tech"
topics: ["ai", "llm", "ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ", "è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³", "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£"]
published: false
---

**ã€Œã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§é™ç•Œã‚’æ„Ÿã˜ã¦ã„ã‚‹ã€**

ã‚¿ã‚¹ã‚¯ãŒè¤‡é›‘ã«ãªã‚‹ã¨ã€1ã¤ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã¯å¯¾å¿œã—ãã‚Œãªããªã‚Šã¾ã™ã€‚

è§£æ±ºç­–ã¯**ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ **ã€‚ã—ã‹ã—ã€é©åˆ‡ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã°ãªã„ã¨ã€ã‚«ã‚ªã‚¹ã«ãªã‚Šã¾ã™ã€‚

ã“ã®è¨˜äº‹ã§ã¯ã€2026å¹´æ™‚ç‚¹ã§ç¢ºç«‹ã•ã‚ŒãŸ**ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³**ã‚’ä½“ç³»çš„ã«è§£èª¬ã—ã¾ã™ã€‚

## ãªãœãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå¿…è¦ã‹

### ã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é™ç•Œ

```
ã‚¿ã‚¹ã‚¯: ã€Œæ–°æ©Ÿèƒ½ã®è¨­è¨ˆã€å®Ÿè£…ã€ãƒ†ã‚¹ãƒˆã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆã€ãƒ‡ãƒ—ãƒ­ã‚¤ã€

ã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:
- ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®åœ§è¿«
- å°‚é–€æ€§ã®å¸Œè–„åŒ–
- ã‚¨ãƒ©ãƒ¼æ™‚ã®å…¨ä½“ç ´ç¶»
- ä¸¦åˆ—å‡¦ç†ä¸å¯
```

### ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆ©ç‚¹

```
åŒã˜ã‚¿ã‚¹ã‚¯ã‚’ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Architect   â”‚    â”‚ Developer   â”‚    â”‚ QA Engineer â”‚
â”‚ è¨­è¨ˆå°‚é–€    â”‚â”€â”€â”€â–ºâ”‚ å®Ÿè£…å°‚é–€    â”‚â”€â”€â”€â–ºâ”‚ ãƒ†ã‚¹ãƒˆå°‚é–€   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                      â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Tech Writer â”‚
              â”‚ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åˆ©ç‚¹:**
- å°‚é–€æ€§ã®æœ€å¤§åŒ–
- ä¸¦åˆ—å‡¦ç†å¯èƒ½
- éšœå®³ã®å±€æ‰€åŒ–
- ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£

---

## 5ã¤ã®åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³

### Pattern 1: Coordinator-Workerï¼ˆã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚¿ãƒ¼ãƒ»ãƒ¯ãƒ¼ã‚«ãƒ¼ï¼‰

**æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã§æ±ç”¨çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³**

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Coordinator    â”‚
                    â”‚  ã‚¿ã‚¹ã‚¯åˆ†è§£ãƒ»çµ±åˆ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Worker A   â”‚      â”‚  Worker B   â”‚      â”‚  Worker C   â”‚
â”‚  å°‚é–€ã‚¿ã‚¹ã‚¯  â”‚      â”‚  å°‚é–€ã‚¿ã‚¹ã‚¯  â”‚      â”‚  å°‚é–€ã‚¿ã‚¹ã‚¯  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Ÿè£…ä¾‹

```python
class Coordinator:
    def __init__(self, workers: dict[str, Worker]):
        self.workers = workers

    async def execute(self, task: Task) -> Result:
        # 1. ã‚¿ã‚¹ã‚¯ã‚’åˆ†è§£
        subtasks = await self._decompose(task)

        # 2. ãƒ¯ãƒ¼ã‚«ãƒ¼ã«å‰²ã‚Šå½“ã¦
        assignments = self._assign_to_workers(subtasks)

        # 3. ä¸¦åˆ—å®Ÿè¡Œ
        results = await asyncio.gather(*[
            self.workers[worker_type].execute(subtask)
            for worker_type, subtask in assignments
        ])

        # 4. çµæœã‚’çµ±åˆ
        return await self._aggregate(results)

    async def _decompose(self, task: Task) -> list[Subtask]:
        """LLMã‚’ä½¿ã£ã¦ã‚¿ã‚¹ã‚¯ã‚’åˆ†è§£"""
        response = await self.llm.generate(
            system="ã‚¿ã‚¹ã‚¯ã‚’ç‹¬ç«‹ã—ãŸå°ã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã—ã¦ãã ã•ã„",
            user=task.description,
            response_format=SubtaskList,
        )
        return response.subtasks

    def _assign_to_workers(self, subtasks: list[Subtask]) -> list[tuple]:
        """ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’é©åˆ‡ãªãƒ¯ãƒ¼ã‚«ãƒ¼ã«å‰²ã‚Šå½“ã¦"""
        assignments = []
        for subtask in subtasks:
            worker_type = self._select_worker(subtask)
            assignments.append((worker_type, subtask))
        return assignments
```

#### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€å¯èª­æ€§ã‚’åˆ¥ã€…ã«ï¼‰
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆï¼ˆAPIã€ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã€ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’åˆ¥ã€…ã«ï¼‰
- ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ï¼ˆæŠ½å‡ºã€å¤‰æ›ã€ãƒ­ãƒ¼ãƒ‰ã‚’åˆ¥ã€…ã«ï¼‰

---

### Pattern 2: Hierarchicalï¼ˆéšå±¤å‹ï¼‰

**å¤§è¦æ¨¡ãƒ»è¤‡é›‘ãªã‚¿ã‚¹ã‚¯å‘ã‘**

```
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Director   â”‚
                         â”‚  æˆ¦ç•¥æ±ºå®š    â”‚
                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                 â–¼                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Manager A  â”‚  â”‚  Manager B  â”‚  â”‚  Manager C  â”‚
       â”‚  ãƒãƒ¼ãƒ ç®¡ç†  â”‚  â”‚  ãƒãƒ¼ãƒ ç®¡ç†  â”‚  â”‚  ãƒãƒ¼ãƒ ç®¡ç†  â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
              â”‚                 â”‚                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
        â–¼           â–¼    â–¼           â–¼    â–¼           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Ÿè£…ä¾‹

```python
class HierarchicalSwarm:
    def __init__(self):
        self.director = DirectorAgent()
        self.managers = {}
        self.workers = {}

    async def execute(self, project: Project) -> Result:
        # 1. DirectorãŒæˆ¦ç•¥ã‚’æ±ºå®š
        strategy = await self.director.plan(project)

        # 2. å„Managerã«ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å‰²ã‚Šå½“ã¦
        domain_results = []
        for domain, manager in self.managers.items():
            if domain in strategy.domains:
                # ManagerãŒã‚µãƒ–ãƒãƒ¼ãƒ ã‚’ç®¡ç†
                result = await manager.execute(
                    strategy.get_domain_tasks(domain),
                    workers=self.workers[domain],
                )
                domain_results.append(result)

        # 3. DirectorãŒçµæœã‚’çµ±åˆãƒ»è©•ä¾¡
        final = await self.director.integrate(domain_results)

        # 4. å¿…è¦ã«å¿œã˜ã¦ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—
        if not final.meets_criteria:
            return await self._refine(final)

        return final

class ManagerAgent:
    async def execute(self, tasks, workers):
        """ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒãƒ¼ãƒ ã‚’ç®¡ç†"""
        # ã‚¿ã‚¹ã‚¯ã‚’åˆ†é…
        assignments = self._distribute(tasks, workers)

        # é€²æ—ç›£è¦–ã¨ãƒªã‚½ãƒ¼ã‚¹å†é…åˆ†
        while not self._all_complete(assignments):
            for worker, task in assignments:
                status = await worker.get_status()
                if status.stuck:
                    # åˆ¥ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã«å†å‰²ã‚Šå½“ã¦
                    await self._reassign(task)

        return self._collect_results(assignments)
```

#### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- å¤§è¦æ¨¡ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
- çµ„ç¹”æ¨ªæ–­çš„ãªã‚¿ã‚¹ã‚¯
- é•·æœŸé–“ã«ã‚ãŸã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†

---

### Pattern 3: Pipelineï¼ˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ï¼‰

**é †åºä¾å­˜ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‘ã‘**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Stage 1   â”‚â”€â”€â”€â–ºâ”‚   Stage 2   â”‚â”€â”€â”€â–ºâ”‚   Stage 3   â”‚â”€â”€â”€â–ºâ”‚   Stage 4   â”‚
â”‚   å…¥åŠ›å‡¦ç†   â”‚    â”‚   åˆ†æ      â”‚    â”‚   ç”Ÿæˆ      â”‚    â”‚   æ¤œè¨¼      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Ÿè£…ä¾‹

```python
class Pipeline:
    def __init__(self, stages: list[Agent]):
        self.stages = stages

    async def execute(self, input_data) -> Result:
        current = input_data

        for i, stage in enumerate(self.stages):
            try:
                # å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®å‡ºåŠ›ãŒæ¬¡ã®å…¥åŠ›
                current = await stage.process(current)

                # ä¸­é–“çµæœã‚’ãƒ­ã‚°
                self._log_intermediate(i, current)

            except StageError as e:
                # ã‚¨ãƒ©ãƒ¼å‡¦ç†: ãƒªãƒˆãƒ©ã‚¤ã¾ãŸã¯ä¸­æ–­
                if e.recoverable:
                    current = await self._retry(stage, current)
                else:
                    raise PipelineError(f"Stage {i} failed", stage=i)

        return current

# ä½¿ç”¨ä¾‹: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
review_pipeline = Pipeline([
    SyntaxCheckerAgent(),      # Stage 1: æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
    SecurityScannerAgent(),    # Stage 2: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
    PerformanceAnalyzerAgent(),# Stage 3: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
    ReviewSummarizerAgent(),   # Stage 4: ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µãƒãƒªç”Ÿæˆ
])
```

#### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
- ETLå‡¦ç†
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆï¼ˆèª¿æŸ»â†’åŸ·ç­†â†’ç·¨é›†â†’å…¬é–‹ï¼‰

---

### Pattern 4: Swarmï¼ˆã‚¹ã‚¦ã‚©ãƒ¼ãƒ ï¼‰

**å‹•çš„ãƒ»è‡ªå¾‹çš„ãªå”èª¿å‘ã‘**

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Agent A   â”‚â—„â”€â”€â”€â”€â”€â”
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
           â”‚             â”‚
           â–¼             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”Œâ”€â”€â–ºâ”‚   Agent B   â”‚â—„â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚      â”‚
â”‚          â”‚             â”‚      â”‚
â”‚          â–¼             â”‚      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚      â”‚
â”‚   â”‚   Agent C   â”‚â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚          â”‚                    â”‚
â”‚          â–¼                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â””â”€â”€â”€â”‚   Agent D   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â€» ä¸­å¤®åˆ¶å¾¡ãªã—ã€å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè‡ªå¾‹çš„ã«å”èª¿
```

#### å®Ÿè£…ä¾‹

```python
class SwarmAgent:
    def __init__(self, agent_id, capabilities, swarm_network):
        self.id = agent_id
        self.capabilities = capabilities
        self.network = swarm_network

    async def run(self):
        """è‡ªå¾‹çš„ã«å‹•ä½œ"""
        while True:
            # 1. ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’ç¢ºèª
            task = await self.network.get_available_task(self.capabilities)

            if task:
                # 2. è‡ªåˆ†ã§å‡¦ç†ã§ãã‚‹ã‹åˆ¤æ–­
                if self._can_handle(task):
                    result = await self._execute(task)
                    await self.network.report_result(task.id, result)
                else:
                    # 3. ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²
                    await self._delegate(task)

            # 4. ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰ã®ä¾é ¼ã‚’ç¢ºèª
            requests = await self.network.get_requests(self.id)
            for req in requests:
                await self._handle_request(req)

    async def _delegate(self, task):
        """ã‚¿ã‚¹ã‚¯ã‚’é©åˆ‡ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        # èƒ½åŠ›ãƒãƒƒãƒãƒ³ã‚°ã§æœ€é©ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ¢ã™
        candidates = await self.network.find_agents(
            required_capabilities=task.required_capabilities,
            exclude=[self.id],
        )

        if candidates:
            best = self._select_best(candidates, task)
            await self.network.request_help(best, task)
```

#### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- æ¢ç´¢ã‚¿ã‚¹ã‚¯ï¼ˆWebã‚¯ãƒ­ãƒ¼ãƒªãƒ³ã‚°ã€æƒ…å ±åé›†ï¼‰
- è² è·åˆ†æ•£ãŒå¿…è¦ãªå‡¦ç†
- è€éšœå®³æ€§ãŒé‡è¦ãªã‚·ã‚¹ãƒ†ãƒ 

---

### Pattern 5: Debate/Adversarialï¼ˆè¨è«–å‹ï¼‰

**å“è³ªå‘ä¸Šãƒ»æ¤œè¨¼å‘ã‘**

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Judge      â”‚
                    â”‚   æœ€çµ‚åˆ¤å®š      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                 â”‚
                    â–¼                 â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚  Proposer   â”‚â—„â”€â–ºâ”‚  Critic     â”‚
             â”‚  ææ¡ˆè€…      â”‚   â”‚  æ‰¹è©•è€…      â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Ÿè£…ä¾‹

```python
class DebateOrchestrator:
    def __init__(self, proposer, critic, judge, max_rounds=3):
        self.proposer = proposer
        self.critic = critic
        self.judge = judge
        self.max_rounds = max_rounds

    async def execute(self, task) -> Result:
        # 1. åˆæœŸææ¡ˆ
        proposal = await self.proposer.generate(task)

        for round in range(self.max_rounds):
            # 2. æ‰¹è©•
            critique = await self.critic.evaluate(proposal)

            # 3. åˆ¤å®š: ååˆ†ãªå“è³ªã‹ï¼Ÿ
            judgment = await self.judge.assess(proposal, critique)

            if judgment.approved:
                return Result(
                    content=proposal,
                    rounds=round + 1,
                    quality_score=judgment.score,
                )

            # 4. æ‰¹è©•ã‚’å…ƒã«æ”¹å–„
            proposal = await self.proposer.refine(proposal, critique)

        # æœ€å¤§ãƒ©ã‚¦ãƒ³ãƒ‰åˆ°é”
        return Result(
            content=proposal,
            rounds=self.max_rounds,
            quality_score=judgment.score,
            warning="Max rounds reached without full approval",
        )

# ä½¿ç”¨ä¾‹: ã‚³ãƒ¼ãƒ‰å“è³ªå‘ä¸Š
code_debate = DebateOrchestrator(
    proposer=CodeWriterAgent(),
    critic=CodeReviewerAgent(),
    judge=QualityAssessorAgent(),
)
```

#### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

- ã‚³ãƒ¼ãƒ‰å“è³ªã®å‘ä¸Š
- æ³•çš„æ–‡æ›¸ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼
- ç ”ç©¶è«–æ–‡ã®æ¤œè¨¼
- æ„æ€æ±ºå®šã®å¦¥å½“æ€§ç¢ºèª

---

## ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã‚¬ã‚¤ãƒ‰

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | æœ€é©ãªçŠ¶æ³ | é¿ã‘ã‚‹ã¹ãçŠ¶æ³ |
|----------|-----------|---------------|
| **Coordinator-Worker** | ä¸¦åˆ—å‡¦ç†å¯èƒ½ãªã‚¿ã‚¹ã‚¯ | é †åºä¾å­˜ãŒå¼·ã„ã‚¿ã‚¹ã‚¯ |
| **Hierarchical** | å¤§è¦æ¨¡ãƒ»é•·æœŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ | å˜ç´”ãªã‚¿ã‚¹ã‚¯ |
| **Pipeline** | æ˜ç¢ºãªã‚¹ãƒ†ãƒ¼ã‚¸ãŒã‚ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ | ä¸¦åˆ—å‡¦ç†ãŒå¿…è¦ãªå ´åˆ |
| **Swarm** | å‹•çš„ãƒ»æ¢ç´¢çš„ãªã‚¿ã‚¹ã‚¯ | å³å¯†ãªé †åºãŒå¿…è¦ãªå ´åˆ |
| **Debate** | å“è³ªãŒæœ€é‡è¦ãªå‡ºåŠ› | é€Ÿåº¦ãŒæœ€é‡è¦ãªå ´åˆ |

---

## é«˜åº¦ãªãƒˆãƒ”ãƒƒã‚¯

### ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³

å®Ÿéš›ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’çµ„ã¿åˆã‚ã›ã¾ã™ï¼š

```python
class HybridOrchestration:
    """
    Hierarchical + Pipeline + Debate ã®çµ„ã¿åˆã‚ã›
    """
    async def execute(self, project):
        # 1. Hierarchical: å…¨ä½“ç®¡ç†
        director = DirectorAgent()
        strategy = await director.plan(project)

        # 2. Pipeline: å„ãƒ•ã‚§ãƒ¼ã‚ºã‚’é †æ¬¡å®Ÿè¡Œ
        for phase in strategy.phases:
            # 3. Coordinator-Worker: ãƒ•ã‚§ãƒ¼ã‚ºå†…ã¯ä¸¦åˆ—
            results = await self._parallel_execute(phase.tasks)

            # 4. Debate: å„ãƒ•ã‚§ãƒ¼ã‚ºã®æˆæœç‰©ã‚’æ¤œè¨¼
            validated = await self._validate_with_debate(results)

            if not validated.approved:
                # ãƒªãƒˆãƒ©ã‚¤
                results = await self._refine_and_retry(phase, validated.feedback)

        return await director.finalize(results)
```

### é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ã®è¨­è¨ˆã‚‚é‡è¦ï¼š

```python
class AgentMessage:
    """A2Aãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«æº–æ‹ ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"""
    sender: str
    receiver: str
    message_type: Literal["request", "response", "notification"]
    payload: dict
    correlation_id: str  # ãƒªã‚¯ã‚¨ã‚¹ãƒˆ-ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å¯¾å¿œä»˜ã‘
    timestamp: datetime

class AgentNetwork:
    async def send(self, message: AgentMessage):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆéåŒæœŸï¼‰"""
        await self.message_queue.publish(
            topic=message.receiver,
            message=message.to_json(),
        )

    async def receive(self, agent_id: str) -> AgentMessage:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡"""
        raw = await self.message_queue.subscribe(topic=agent_id)
        return AgentMessage.from_json(raw)
```

### éšœå®³å‡¦ç†

```python
class FaultTolerantOrchestrator:
    async def execute_with_fallback(self, task, primary_worker, fallback_workers):
        try:
            return await asyncio.wait_for(
                primary_worker.execute(task),
                timeout=30.0,
            )
        except (asyncio.TimeoutError, WorkerError) as e:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            for fallback in fallback_workers:
                try:
                    return await fallback.execute(task)
                except WorkerError:
                    continue

            raise AllWorkersFailedError(task)
```

---

## 2026å¹´ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ¯”è¼ƒ

| ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ | å¼·ã¿ | å¼±ã¿ |
|---------------|------|------|
| **LangGraph** | ã‚°ãƒ©ãƒ•ãƒ™ãƒ¼ã‚¹ã€æŸ”è»Ÿ | å­¦ç¿’æ›²ç·š |
| **OpenAI Agents SDK** | ã‚·ãƒ³ãƒ—ãƒ«ã€æœ¬ç•ªå“è³ª | ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºé™å®š |
| **Microsoft Agent Framework** | ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºçµ±åˆ | é‡ã„ |
| **Swarms** | å¤§è¦æ¨¡ã‚¹ã‚¦ã‚©ãƒ¼ãƒ  | è¤‡é›‘ |

:::message
**2026å¹´ã®ç¾å®Ÿ:** ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®æ€§èƒ½å·®ã¯ã€ä¸»ã«**ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæˆ**ã§ç”Ÿã˜ã‚‹ã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ãƒãƒ³ãƒ‰ã‚ªãƒ•è‡ªä½“ã¯å¤§å·®ãªã„ã€‚
:::

---

## ã¾ã¨ã‚

### 5ã¤ã®åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³

1. **Coordinator-Worker**: ã‚·ãƒ³ãƒ—ãƒ«ã§æ±ç”¨çš„
2. **Hierarchical**: å¤§è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå‘ã‘
3. **Pipeline**: é †åºä¾å­˜ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
4. **Swarm**: è‡ªå¾‹ãƒ»å‹•çš„å”èª¿
5. **Debate**: å“è³ªé‡è¦–ã®æ¤œè¨¼

### è¨­è¨ˆåŸå‰‡

- **å˜ä¸€è²¬ä»»**: å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯1ã¤ã®å°‚é–€é ˜åŸŸ
- **ç–çµåˆ**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ä¾å­˜ã‚’æœ€å°åŒ–
- **éšœå®³éš”é›¢**: 1ã¤ã®å¤±æ•—ãŒå…¨ä½“ã«æ³¢åŠã—ãªã„
- **è¦³æ¸¬å¯èƒ½æ€§**: å…¨ã¦ã®ã‚„ã‚Šå–ã‚Šã‚’ãƒ­ã‚°

---

## å‚è€ƒãƒªãƒ³ã‚¯

- [Choosing the Right Orchestration Pattern (Kore.ai)](https://www.kore.ai/blog/choosing-the-right-orchestration-pattern-for-multi-agent-systems)
- [Design Patterns for Multi-Agent Orchestration](https://www.wethinkapp.ai/blog/design-patterns-for-multi-agent-orchestration)
- [Swarms Documentation](https://docs.swarms.world/en/latest/swarms/concept/swarm_architectures/)
- [Multi-Agent Collaboration via Evolving Orchestration (arXiv)](https://arxiv.org/html/2505.19591v1)

---

**ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã£ã¦ã„ã¾ã™ã‹ï¼Ÿå®Ÿè£…ã§å›°ã£ãŸã“ã¨ãŒã‚ã‚Œã°ã‚³ãƒ¡ãƒ³ãƒˆã§å…±æœ‰ã—ã¦ãã ã•ã„ï¼**
